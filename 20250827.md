I began work last weekend on the loop sampler which is based on "lung" the reaktor instrument I created after graduating school.


Because this one has so many moving parts compared to more simplistic modules, I'm taking a more modular approach to both the firmware development and the build itself.

Most other modules have been fabricated, wired, and then firmware written, but with this one, I'm wiring in stages and then writing firmware for each newly added component.

So far, this is working great. It's allowing me to validate hardware and program features without the overwhelming distraction of starting with a blank canvas. It also allows me to debug hardware issues without interference from other components or firmware systems.

As soon as everything was attached to the front panel, I wired the XXL up to the display and had to debug for a bit since I had shifted the wiring by a single pin. Once that was fixed, I'd gotten the display working and was surprised by how bright it was. It's a 2.08" grayscale SH1122 OLED, and we're running it with u8g2 graphics library

I had GPT write a simple animated test sketch. Once that was up and running, I had Claude (Opus 4.1 extended) combine my previous SD card -> PSRAM loader sketch and the display test, so that the serial debug output would scroll on the display. Sweet! It worked with minimal fuss.

Next, I had Claude modularize the code into a main sketch, and separate display and SD card headers. I'd planned to use Git branches to manage development of this, to keep track of "last known working" configurations, since I figured I'd be breaking things quite a bit along the way!

I created a lung-dev branch to serve as a home base for feature branches. When feature branches are in a working state, they get merged into lung-dev. When lung-dev reaches a working milestone and is stable, it gets merged back into main.

--- 

Now that we have display and SD card loading working, it's time to create a file browsing system using the rotary encoder. The idea is simple: Turning the encoder opens the sample menu, which lists 6-8 samples (however many can fit on the display without being hard to read). Rotating the encoder scrolls through the list of samples. The currently selected sample is denoted by full-brightness text. All other displayed samples are dimmed. Clicking the encoder loads the sample. We can keep the current behavior of printing some info about the read speed, I'd like to see how long it took to load each sample. That's it. Pretty basic!  Encoder is wired thusly: ENC_SW=GPIO8 ENC_CLK=GPIO22 ENC_DT=GPIO23. I have included an example from the EEncoder.h library, which we'll use to handle the encoder. If it makes sense to create a new header file here, to maintain modularity, then do so. This module will eventually have several knobs and CV inputs but i'm pretty sure those will be handled by the DMA engine and might not belong here. So maybe "user-controls.h" or whatever we name this will just handle the encoder and the SPDT switch on the front panel.

Development stumbled today. Claude was overloaded and wouldn't accept any input. I've noticed this pattern; he's usually having issues in the morning when I'm ready to work. Then at night, he runs just fine. Maybe coincidence? Maybe not.

Either way, banging my code against GPT-5 for two hours reminded me of trying to have GPT-3 write code. Kinda sorta looks like code, but with major flaws.

The majority of the trouble revolved around trying to modularize within the Arduino format: having separate header files for separate functional parts, like how mutable modules are coded.

You could easily bypass this by keeping everything in a single .ino file, but the issue with that is that a single file that's 700 lines long winds up consuming too many tokens and saps usage limits on Opus 4.1 extended, which is the only model worth using in my opinion.

The irony is that Opus 4.1 extended could probably modularize the *right* way, without generating a bunch of non-compiling garbage first.

I think part of the problem may have been that GPT was pulling in a lot of C++ and patterns from more mainstream software development that don't translate well or aren't strictly necessary for what we're trying to do. I'm wondering if we could keep things more in C land while still being modular, and only bring in C++ patterns when there's a really good reason to do so. "A really good reason" meaning that it won't otherwise work, or will be way too inefficient.

Since claude prompts persist through refreshes, I'll try triggering output throughout the day and see if we can get some progress going by this evening. 

I'm seriously considering dropping my subscription to GPT. It's only a matter of time before 4o disappears. And I don't use it too much these days, except to bounce ideas off of.