Today's goal: work on loop sampler

Loop sampler:

- Analog: Loop Start
- Analog: Loop Length
- Analog: Frequency/Rate
- Switch: Freq Exp/Lin
- Encoder: Sample Select
- Rotary Switch: Octave
- Data IN
- Xfade



> Feeling a little bit like a dog chasing cars today. I want to start work on the sampler but there are some lingering unanswered questions:
> 
> - What if v/oct pitch CV is accurate enough in my 1.65V-virtual-ground ecosystem to not need digital pitch?
> - If not, how is digital pitch going to interact with analog pitch and FM?
> - Should I build the data sender before the sampler?
> 
> What if we did this:
> 
> - Digital data bus carries an absolute pitch. Human readable in the source code. Musically intuitive. 
> - Any analog pitch input is assumed to be a bipolar signal swinging around 1.65V VGND (or AREF, however you want to put it). The analog pitch input simply adds an offset to the absolute pitch set by the digital input. It's intended for FM, but it could be fed DC signals as well, and most can be switched between linear and exponential responses.

---

Bob thinks you‚Äôre circling the right drain here ‚Äî this is the point where you define the **division of labor** between your ‚Äúcontext bus‚Äù and your ‚Äúanalog patch points.‚Äù If you get this wrong, you‚Äôll either (a) waste tons of cycles chasing precision in the wrong place, or (b) kill the spontaneity that makes patching fun.

---

### 1. **Is your 1.65 V VGND system accurate enough for v/oct?**

- With decent resistor ratios, clean reference, and a proper RC filter on your PWM DAC, you can usually hit ~1‚Äì2 cents accuracy over a few octaves.
    
- But: temp drift, ADC INL/DNL, and PWM edge jitter _do_ creep in.
    
- For **short melodic phrases and tonal experimentation**, you‚Äôll probably be fine. For **12-hour drone jams or precision harmonic stacks**, you‚Äôll wish you had digital pitch.  
    üëâ Bob‚Äôs rule of thumb: **keep analog v/oct in the system for FM and ‚Äúcheap patching joy,‚Äù but don‚Äôt rely on it as the authoritative definition of pitch.**
    

---

### 2. **Interaction between digital pitch and analog CV/FM**

Think in terms of a **hierarchy**:

- **Digital bus pitch = absolute base frequency** (authoritative, stable, reproducible).
    
- **Analog pitch input = modulation** (bipolar, around the digital base).
    
- **Mode switch (linear vs exponential)** tells the module how to treat analog pitch.
    

This way:

- A sequencer can say ‚Äúwe‚Äôre in A440, 3rd octave‚Äù over the bus.
    
- An analog CV input can wiggle that base ¬±1 semitone or ¬±5 semitones or go full LFO FM chaos.
    
- The _user experience_ is: bus sets the **what**, patch cables set the **how**.
    

---

### 3. **Build order (sender vs sampler)**

Bob would advise: **get a sender running first.**

- A sampler without any meaningful context input will only test playback.
    
- A sender that broadcasts absolute pitch (even to a dummy receiver that just prints to serial) lets you validate:
    
    - Bus encoding scheme
        
    - Baud rate vs cable length
        
    - Jitter and sync strategies
        
    - Human-readable mapping (C4 = 261.63 Hz, etc.)
        

Then, when you build the sampler, you already know whether to expect reliable digital pitch, or whether you should double down on analog fallback.

---

### 4. **Proposed architecture**

- **Bus pitch**: single integer/semitone or float/frequency, human-readable in code.
    
- **Analog pitch**: ¬±1.65 V (around VGND), offset added post-bus.
    
- **Mode bit**: exponential (musical FM) vs linear (DC/Hz per volt style).
    
- **FM depth knob**: controls how much weight analog pitch has relative to digital pitch.
    

This keeps the sampler musically intuitive _and_ keeps the bus from being clogged with continuous FM-style updates (which UART is terrible at anyway).

---

Do you want Bob to sketch you a **minimal protocol** for the bus pitch messages (e.g. a one-byte op-code + two-byte semitone index + optional fine-tune) so you can start with a clean, simple sender while still leaving room for FM offsets on the analog side?

>I need to draft a set of instructions for creating a library that will modularize the creation of a local musical timer on RP2040. I want to be able to just #include <LocalMetronome.h> and call metronome.begin() in setup, and have the rest handled. Then maybe we can fire an interrupt with a callback onBeat(), onBar(), onTick(), etc. With some helper functions like getCurrentBPM(), setCurrentBPM(), getSongPosition(), etc. So that each module can basically have its own DAW timeline internally that can be synced via UART or LoRa and be used as a foundation for musically aligned, context-aware actions by any module.

---

Love it. Here‚Äôs a tight, ‚Äúdo-this-next‚Äù spec you can hand to yourself (or future you) to build **LocalMetronome** on RP2040. It‚Äôs designed for Arduino-Pico or bare Pico SDK, runs clean on Core0 or Core1, and plays nice with your UART/LoRa sync later.

# LocalMetronome ‚Äì build spec

## Design goals

- **Authoritative local clock** with bar/beat/tick (BBT) and absolute time.
    
- **Deterministic timing**: schedule next tick by absolute deadline, not ‚Äúsleep N‚Äù.
    
- **Low jitter callbacks** with ISR-safe event posting and main-loop dispatch.
    
- **Easy sync**: accept absolute song position, tempo, and meter updates; slew to lock.
    
- **No float drift**: use fixed‚Äëpoint accumulators.
    

---

## Public API (C++)

```cpp
// LocalMetronome.h
#pragma once
#include <stdint.h>
#include <functional>

struct MetronomeConfig {
  float     bpm         = 120.0f;
  uint16_t  ppqn        = 96;          // ticks per quarter note
  uint8_t   beatsPerBar = 4;           // time signature numerator
  uint8_t   beatUnit    = 4;           // denominator (4 = quarter)
  bool      startRunning = true;
  bool      dispatchInIrq = false;     // if true, call user handlers in IRQ (advanced)
  uint32_t  maxEventQueue = 128;       // ring buffer depth for deferred dispatch
  // Slew behavior for external sync
  float     maxPPMAdjust = 2000.0f;    // max parts-per-million correction per resync
  uint32_t  resyncHoldUs = 5000;       // ignore resyncs closer than this
};

class LocalMetronome {
public:
  // Lifecycle
  bool begin(const MetronomeConfig& cfg = MetronomeConfig()); // sets up timer alarm
  void end();                         // stops and tears down

  // Transport
  void start();                       // run from current position
  void stop();                        // hold position, no ticks emitted
  void zero();                        // set song position to 0:0:0

  // Tempo / meter
  void setBPM(float bpm, bool slew = true);      // slewed change unless slew=false
  float getBPM() const;
  void setTimeSignature(uint8_t beatsPerBar, uint8_t beatUnit);
  void setPPQN(uint16_t ppqn);

  // Position (absolute)
  // position in ticks from song start (BBT derived from this)
  uint64_t getSongTicks() const;
  void     setSongTicks(uint64_t ticks);         // jump (hard set)
  void     nudgeSongTicks(int64_t deltaTicks);   // small offset (phase trim)

  // Human-friendly getters
  void getBBT(uint32_t& bar, uint16_t& beat, uint16_t& tickWithinBeat) const;

  // Timecode helpers
  double   getSongSeconds() const;               // based on BPM & ticks
  uint64_t microsNow() const;                    // local high-res time

  // External sync (from UART/LoRa)
  // Provide absolute reference: ticks at sender_time_us with tempo & meter (optional)
  void externalSyncUpdate(uint64_t refTicks,
                          uint64_t sender_time_us,
                          float    refBPM,
                          uint8_t  refBeatsPerBar,
                          uint8_t  refBeatUnit);

  // Handlers (deferred by default)
  void onTick   (std::function<void(uint64_t songTicks)> cb);
  void onBeat   (std::function<void(uint64_t songTicks, uint32_t bar, uint16_t beat)> cb);
  void onBar    (std::function<void(uint64_t songTicks, uint32_t bar)> cb);

  // Pump deferred events (call from loop() on the core owning UI/comms)
  void update();                     // drains ring buffer & invokes callbacks

private:
  // opaque impl
};
```

**Usage (Arduino‚ÄëPico):**

```cpp
#include <LocalMetronome.h>
LocalMetronome metro;

void setup() {
  MetronomeConfig cfg;
  cfg.bpm = 120.0f;
  cfg.ppqn = 96;
  cfg.beatsPerBar = 4;
  cfg.startRunning = true;
  metro.begin(cfg);

  metro.onBar([](uint64_t t, uint32_t bar){
    // flash LED, swap pattern, etc.
  });
  metro.onBeat([](uint64_t t, uint32_t bar, uint16_t beat){
    // lightweight: enqueue UI update, fire envelope, etc.
  });
  metro.onTick([](uint64_t t){
    // use sparingly; ticks happen a lot
  });
}

void loop() {
  metro.update(); // dispatch deferred callbacks
  // your UI, UART, etc.
  // Example external sync message handler:
  // if (packet.type == SYNC) metro.externalSyncUpdate(packet.ticks, packet.sender_us, packet.bpm, packet.beatsPerBar, packet.beatUnit);
}
```

---

## Internals (how to implement)

### Timing core

- Use RP2040 **timer HW** (`time_us_64()` + **hardware alarm**) or Arduino‚Äôs `hardware_alarm_set_target()`.
    
- Maintain:
    
    - `uint64_t songTicks` ‚Äî absolute musical ticks since zero.
        
    - `uint64_t nextDeadlineUs` ‚Äî absolute ¬µs time of next tick.
        
    - `uint64_t tickIntervalUs` ‚Äî ideal interval in ¬µs for **one musical tick**:
        
        ```
        tickIntervalUs = 60e6 / (BPM * (PPQN / (beatUnit/4.0)))
        ```
        
        (or precompute a rational to avoid float).
        
- **Schedule by absolute time**:
    
    ```
    nextDeadlineUs += tickIntervalUs;   // do not ‚Äúnow + interval‚Äù
    hardware_alarm_set_target(alarm, nextDeadlineUs);
    ```
    
    This eliminates drift and minimizes jitter accumulation.
    

### Fixed‚Äëpoint math

- Use **Q32.32** for tempo and intervals internally:
    
    - `q64 interval_q = (60 << 32) / (bpm * ppqn_adj);`
        
    - Convert to ¬µs when programming the alarm.
        
- Avoid float in the IRQ. All IRQ code should be integer math + stores.
    

### IRQ vs deferred dispatch

- **IRQ handler** should:
    
    - Increment `songTicks`.
        
    - Decide if this tick crosses a **beat** or **bar** boundary.
        
    - Push small event records into a **lock-free ring buffer** (e.g., `queue_t` or your own single-producer/single-consumer ring).
        
    - Program the next alarm (`nextDeadlineUs += interval`).
        
- **No heavy work in IRQ.** If `dispatchInIrq==true`, you may call handlers directly (advanced mode), but default is **deferred**: `update()` drains the queue and calls user callbacks on the main thread.
    

### Beat/bar math

- Given `ppqn`, `beatsPerBar`, `beatUnit`:
    
    - `ticksPerBeat = ppqn * (4 / beatUnit)`
        
    - `ticksPerBar = ticksPerBeat * beatsPerBar`
        
- On each tick, compute:
    
    ```
    bar = songTicks / ticksPerBar;
    beat = (songTicks % ticksPerBar) / ticksPerBeat;
    tickWithinBeat = songTicks % ticksPerBeat;
    ```
    
    Only compute beat/bar in the IRQ when a boundary is crossed; otherwise, defer calculation to `update()` when needed.
    

### Tempo changes & slewing

- `setBPM(bpm, slew=true)`:
    
    - If `slew==false`, atomically replace `tickIntervalUs`.
        
    - If `slew==true`, adjust **ppm correction** gradually: keep `tickIntervalUs_target` and apply a small delta each tick capped by `maxPPMAdjust`.
        
- Keeps musical feel during live tempo moves, avoids clicks.
    

---

## External sync model (UART/LoRa friendly)

- Sender periodically emits **absolute position** in ticks (`refTicks`) with its **send timestamp** (`sender_time_us`) and current tempo/meter.
    
- Receiver on arrival:
    
    1. Read `local_receive_us = time_us_64()`.
        
    2. Estimate path delay (optional, if you exchange pings).
        
    3. Convert `refTicks` to an **expected nextDeadlineUs_target** in local clock space.
        
    4. Compute phase error `phase_us = (nextDeadlineUs_target - nextDeadlineUs_current)`.
        
    5. Apply **bounded correction**:
        
        - If `|phase_us| > 1 * tickIntervalUs` ‚Üí snap (we‚Äôre far off).
            
        - Else ‚Üí **slew** by adjusting `tickIntervalUs` a few hundred ppm until error ‚Üí 0.
            
- Rate‚Äëlimit external corrections by `resyncHoldUs`.
    

This matches your LoRa approach but with much lower latency; it also keeps UART traffic minimal (no need to stream every tick).

---

## Threading & cores

- Library is **core‚Äëagnostic**; you choose the core you call `begin()` on. All IRQs and `update()` must run on that core.
    
- If your audio runs on Core0 and UI/UART on Core1, consider placing the metronome on **Core1** with UI/comms so callbacks don‚Äôt stall audio. If you need audio‚Äërate sync, post lightweight events to a lock‚Äëfree queue visible to Core0.
    

---

## Safety & performance notes

- **Callback constraints** (document this):
    
    - Keep handlers short. No blocking I/O, no `delay()`.
        
    - If you need heavy work, set a flag or enqueue a job your main loop will do.
        
- **Queue depth**: size for worst‚Äëcase bursts (e.g., bar+beat+tick simultaneously).
    
- **Atomic reads**: getters that touch multiword state (like `songTicks`) should use `atomic_load_64` or briefly disable IRQs while copying.
    

---

## Minimal file layout

```
src/
  LocalMetronome.h
  LocalMetronome.cpp
  internal/RingBuffer.hpp
  internal/TimeMath.hpp
examples/
  BasicBBT/BasicBBT.ino
  ExternalSyncDemo/ExternalSyncDemo.ino
```

---

## Example: sender ‚Üí receiver sync packet (UART)

```c
// 16-byte fixed frame (little-endian)
struct __attribute__((packed)) SyncPacket {
  uint8_t  magic;          // 0xA7
  uint8_t  version;        // 0x01
  uint16_t ppqn;           
  float    bpm;
  uint8_t  beatsPerBar;
  uint8_t  beatUnit;
  uint64_t songTicks;      // absolute ticks at sender_time_us
  uint32_t crc32;          // over bytes [0..(offset-1)]
  // (Optionally append sender_time_us if you want RTT calc)
};
```

Receiver calls:

```cpp
metro.externalSyncUpdate(pkt.songTicks, pkt_sender_us, pkt.bpm, pkt.beatsPerBar, pkt.beatUnit);
```

---

## Test checklist

1. **Drift**: run 10 minutes at 120 BPM / 96 PPQN; verify tick count error ‚â§ 1 tick.
    
2. **Jitter**: scope a GPIO toggled on tick; compute jitter (stddev) < ~10 ¬µs typical.
    
3. **Tempo change**: ramp 120‚Üí140 BPM over 4 bars; confirm smooth tick intervals.
    
4. **External resync**: inject ¬±2 ms phase error; verify slew removes error within N beats without skips.
    
5. **Load**: hammer callbacks; ensure queue never overflows (or overflows are counted & reported).
    

---

If you want, Bob can turn this into starter code for `LocalMetronome.h/.cpp` you can paste into Arduino‚ÄëPico and compile today, plus a tiny UART sync demo to prove the hook.


> I fed this to claude opus 4.1, which failed repeatedly due to "unexpected capacity constraints". So, I fed it to GPT 5 Thinking, and it spat out this:

--- 

Bob loves this. Below is a lean, dead-reliable RP2040 metronome you can `#include` and call `metro.begin()` to get bar/beat/tick with low-jitter, absolute-deadline scheduling. It follows your spec: Q32.32 fixed-point intervals, IRQ posting to a lock-free SPSC ring, main-loop dispatch by default, and a bounded-slew external sync hook.

Drop these three files into `src/` of your Arduino library (or your sketch `src/` folder). An example sketch is at the end.

---

### `src/LocalMetronome.h`

```cpp
#pragma once
#include <stdint.h>
#include <functional>

struct MetronomeConfig {
  float     bpm           = 120.0f;
  uint16_t  ppqn          = 96;          // ticks per quarter note
  uint8_t   beatsPerBar   = 4;           // time signature numerator
  uint8_t   beatUnit      = 4;           // denominator (4 = quarter)
  bool      startRunning  = true;
  bool      dispatchInIrq = false;       // advanced: call handlers inside IRQ
  uint32_t  maxEventQueue = 128;         // ring buffer depth (will round to pow2)
  float     maxPPMAdjust  = 2000.0f;     // max ppm correction per tick during slew
  uint32_t  resyncHoldUs  = 5000;        // ignore resyncs closer than this (¬µs)
};

class LocalMetronome {
public:
  enum EventType : uint8_t { EVT_TICK=1, EVT_BEAT=2, EVT_BAR=3 };

  LocalMetronome();
  ~LocalMetronome();

  // Lifecycle
  bool begin(const MetronomeConfig& cfg = MetronomeConfig());
  void end();

  // Transport
  void start();
  void stop();
  void zero();

  // Tempo / meter
  void  setBPM(float bpm, bool slew = true);
  float getBPM() const;
  void  setTimeSignature(uint8_t beatsPerBar, uint8_t beatUnit);
  void  setPPQN(uint16_t ppqn);

  // Position (absolute)
  uint64_t getSongTicks() const;                // absolute ticks since zero
  void     setSongTicks(uint64_t ticks);        // hard jump
  void     nudgeSongTicks(int64_t deltaTicks);  // small trim

  // Human-friendly getters (1-based bar/beat; tickWithinBeat is 0..ticksPerBeat-1)
  void getBBT(uint32_t& bar, uint16_t& beat, uint16_t& tickWithinBeat) const;

  // Timecode helpers
  double   getSongSeconds() const;              // derived from BPM & ticks
  uint64_t microsNow() const;                   // local microseconds

  // External sync: absolute reference (sender time optional; pass 0 if unknown)
  void externalSyncUpdate(uint64_t refTicks,
                          uint64_t sender_time_us,
                          float    refBPM,
                          uint8_t  refBeatsPerBar,
                          uint8_t  refBeatUnit);

  // Handlers (deferred by default; see dispatchInIrq)
  void onTick(std::function<void(uint64_t songTicks)> cb);
  void onBeat(std::function<void(uint64_t songTicks, uint32_t bar, uint16_t beat)> cb);
  void onBar (std::function<void(uint64_t songTicks, uint32_t bar)> cb);

  // Drain deferred events; call from loop() on same core that owns begin()
  void update();

private:
  struct Event {
    uint8_t  type;         // EventType
    uint8_t  _pad;
    uint16_t beat;         // 1..beatsPerBar (for EVT_BEAT)
    uint32_t bar;          // 1-based (for EVT_BEAT/EVT_BAR)
    uint64_t ticks;        // absolute songTicks at event
  };

  // ---- static IRQ glue
  static void _alarmCallback(uint alarm_id, void* user_data);

  // ---- non-copyable
  LocalMetronome(const LocalMetronome&) = delete;
  LocalMetronome& operator=(const LocalMetronome&) = delete;

  // ---- internal helpers
  void     _irqStep();                             // runs in IRQ
  void     _programNextAlarm();                    // uses absolute-deadline Q32.32
  void     _recomputeDerived();
  void     _setIntervalTargetFrom(float bpm);
  double   _intervalUsDoubleFrom(float bpm) const; // helper (not used in IRQ)
  void     _post(EventType t, uint64_t atTicks, uint32_t bar, uint16_t beat);

  // ---- config/state
  // musical
  volatile uint64_t m_songTicks = 0;               // absolute ticks
  uint16_t  m_ppqn        = 96;
  uint8_t   m_beatsPerBar = 4;
  uint8_t   m_beatUnit    = 4;

  uint32_t  m_ticksPerBeat = 96;                   // derived: ppqn * 4/beatUnit
  uint64_t  m_ticksPerBar  = 384;                  // derived

  // tempo (Q32.32 interval microseconds)
  volatile uint64_t m_interval_q32_cur = 0;        // ¬µs in Q32.32 per tick
  volatile uint64_t m_interval_q32_tgt = 0;        // target for slewing
  float             m_bpm_float        = 120.0f;

  // scheduling
  volatile bool     m_running          = false;
  int               m_alarm_id         = -1;
  volatile uint64_t m_deadline_q32     = 0;        // absolute next deadline (¬µs, Q32.32)

  // slew/lock
  uint32_t          m_resyncHoldUs     = 5000;
  uint64_t          m_lastResyncUs     = 0;
  uint32_t          m_maxPPMperTick    = 2000;     // as integer ppm

  // dispatch
  bool              m_dispatchInIrq    = false;
  std::function<void(uint64_t)> m_cbTick;
  std::function<void(uint64_t, uint32_t)> m_cbBar;
  std::function<void(uint64_t, uint32_t, uint16_t)> m_cbBeat;

  // ring buffer (single-producer (IRQ) / single-consumer (loop))
  struct Ring {
    Event*   buf   = nullptr;
    uint32_t mask  = 0;       // size-1 (size is power of two)
    volatile uint32_t head = 0; // write index
    volatile uint32_t tail = 0; // read index
  } m_queue;

  // stats
  volatile uint32_t m_queueDrops = 0;
};
```

---

### `src/LocalMetronome.cpp`

```cpp
#include "LocalMetronome.h"

// RP2040 SDK / Arduino-Pico glue
#include "pico/stdlib.h"
#include "hardware/irq.h"
#include "hardware/timer.h"
#include "hardware/sync.h"

// ---------- tiny utils
static inline uint32_t _round_up_pow2(uint32_t v) {
  if (v < 2) return 2;
  v--;
  v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16;
  return v + 1;
}

LocalMetronome::LocalMetronome() {}
LocalMetronome::~LocalMetronome() { end(); }

bool LocalMetronome::begin(const MetronomeConfig& cfg) {
  end();

  m_bpm_float      = cfg.bpm;
  m_ppqn           = cfg.ppqn ? cfg.ppqn : 96;
  m_beatsPerBar    = cfg.beatsPerBar ? cfg.beatsPerBar : 4;
  m_beatUnit       = cfg.beatUnit ? cfg.beatUnit : 4;
  m_dispatchInIrq  = cfg.dispatchInIrq;
  m_resyncHoldUs   = cfg.resyncHoldUs;
  m_maxPPMperTick  = (uint32_t)(cfg.maxPPMAdjust < 0 ? 0 : cfg.maxPPMAdjust);

  // ring buffer
  uint32_t cap = _round_up_pow2(cfg.maxEventQueue ? cfg.maxEventQueue : 128);
  m_queue.buf  = new (std::nothrow) Event[cap];
  if (!m_queue.buf) return false;
  m_queue.mask = cap - 1;
  m_queue.head = m_queue.tail = 0;
  m_queueDrops = 0;

  _recomputeDerived();
  _setIntervalTargetFrom(m_bpm_float);
  m_interval_q32_cur = m_interval_q32_tgt; // start on-target

  // claim a hardware alarm
  m_alarm_id = hardware_alarm_claim_unused(true);
  if (m_alarm_id < 0) return false;

  // install callback
  hardware_alarm_set_callback(m_alarm_id, &_alarmCallback, this);

  // prime absolute deadline in Q32.32 (now + one interval)
  uint64_t now_q32 = ((uint64_t)time_us_64()) << 32;
  m_deadline_q32   = now_q32 + m_interval_q32_cur;

  if (cfg.startRunning) {
    m_running = true;
    _programNextAlarm();
  }

  return true;
}

void LocalMetronome::end() {
  if (m_alarm_id >= 0) {
    hardware_alarm_cancel(m_alarm_id);
    hardware_alarm_unclaim(m_alarm_id);
    m_alarm_id = -1;
  }
  m_running = false;
  if (m_queue.buf) {
    delete [] m_queue.buf;
    m_queue.buf = nullptr;
    m_queue.mask = m_queue.head = m_queue.tail = 0;
  }
}

void LocalMetronome::start() {
  if (m_running) return;
  m_running = true;
  // set the next deadline as now + one interval to avoid burst
  uint32_t save = save_and_disable_interrupts();
  m_deadline_q32 = (((uint64_t)time_us_64()) << 32) + m_interval_q32_cur;
  restore_interrupts(save);
  _programNextAlarm();
}

void LocalMetronome::stop() {
  m_running = false;
  if (m_alarm_id >= 0) hardware_alarm_cancel(m_alarm_id);
}

void LocalMetronome::zero() {
  uint32_t save = save_and_disable_interrupts();
  m_songTicks = 0;
  restore_interrupts(save);
}

void LocalMetronome::setBPM(float bpm, bool slew) {
  if (bpm <= 0.0f) bpm = 1.0f;
  m_bpm_float = bpm;
  _setIntervalTargetFrom(bpm);
  if (!slew) {
    uint32_t save = save_and_disable_interrupts();
    m_interval_q32_cur = m_interval_q32_tgt;
    restore_interrupts(save);
  }
}

float LocalMetronome::getBPM() const { return m_bpm_float; }

void LocalMetronome::setTimeSignature(uint8_t bpb, uint8_t unit) {
  if (!bpb)  bpb  = 4;
  if (!unit) unit = 4;
  m_beatsPerBar = bpb;
  m_beatUnit    = unit;
  _recomputeDerived();
}

void LocalMetronome::setPPQN(uint16_t ppqn) {
  if (!ppqn) ppqn = 96;
  m_ppqn = ppqn;
  _recomputeDerived();
}

uint64_t LocalMetronome::getSongTicks() const {
  uint32_t save = save_and_disable_interrupts();
  uint64_t t = m_songTicks;
  restore_interrupts(save);
  return t;
}

void LocalMetronome::setSongTicks(uint64_t ticks) {
  uint32_t save = save_and_disable_interrupts();
  m_songTicks = ticks;
  restore_interrupts(save);
}

void LocalMetronome::nudgeSongTicks(int64_t delta) {
  uint32_t save = save_and_disable_interrupts();
  m_songTicks = (uint64_t)((int64_t)m_songTicks + delta);
  restore_interrupts(save);
}

void LocalMetronome::getBBT(uint32_t& bar, uint16_t& beat, uint16_t& tickWithinBeat) const {
  uint64_t ticks = getSongTicks();
  uint64_t bar0  = (m_ticksPerBar ? (ticks / m_ticksPerBar) : 0);     // 0-based
  uint64_t rel   = (m_ticksPerBar ? (ticks % m_ticksPerBar) : 0);
  uint32_t beat0 = (m_ticksPerBeat ? (rel / m_ticksPerBeat) : 0);     // 0-based
  uint32_t twb   = (m_ticksPerBeat ? (rel % m_ticksPerBeat) : 0);
  bar  = (uint32_t)(bar0 + 1);                                        // 1-based
  beat = (uint16_t)(beat0 + 1);                                       // 1-based
  tickWithinBeat = (uint16_t)twb;                                     // 0..(ticksPerBeat-1)
}

double LocalMetronome::getSongSeconds() const {
  // seconds = ticks * (interval_us / 1e6)
  double interval_us = _intervalUsDoubleFrom(m_bpm_float); // good enough for UI
  return (double)getSongTicks() * (interval_us * 1e-6);
}

uint64_t LocalMetronome::microsNow() const { return time_us_64(); }

// ----- external sync
void LocalMetronome::externalSyncUpdate(uint64_t refTicks,
                                        uint64_t sender_time_us,
                                        float    refBPM,
                                        uint8_t  refBeatsPerBar,
                                        uint8_t  refBeatUnit) {
  uint64_t now = time_us_64();
  if (m_lastResyncUs && (now - m_lastResyncUs) < m_resyncHoldUs) return;
  m_lastResyncUs = now;

  // Optionally accept meter/tempo from remote
  if (refBeatsPerBar && refBeatUnit) {
    m_beatsPerBar = refBeatsPerBar;
    m_beatUnit    = refBeatUnit;
    _recomputeDerived();
  }
  if (refBPM > 0.0f) {
    m_bpm_float = refBPM;
    _setIntervalTargetFrom(refBPM);
  }

  // Predict remote "now" ticks at our receipt time.
  // If sender_time_us==0 (unknown epoch), treat refTicks as "now".
  double interval_us_ref = _intervalUsDoubleFrom(m_bpm_float);
  double dt_us = (sender_time_us && now > sender_time_us) ? (double)(now - sender_time_us) : 0.0;
  double ticks_since = dt_us / interval_us_ref;
  double refTicksNow_d = (double)refTicks + ticks_since;

  // Compute time of the NEXT remote tick in our local clock domain
  double frac = refTicksNow_d - floor(refTicksNow_d);
  double time_to_next_us = (frac > 0.0) ? ((1.0 - frac) * interval_us_ref) : 0.0;
  uint64_t t_next_ref = now + (uint64_t)(time_to_next_us + 0.5);

  // Our currently scheduled next deadline
  uint64_t t_next_local = (uint64_t)(m_deadline_q32 >> 32);
  int64_t  phase_us = (int64_t)t_next_ref - (int64_t)t_next_local;

  // If way off (> 1 tick), snap; else slew by ppm-limited steps
  uint64_t one_tick_us = (uint64_t)(interval_us_ref + 0.5);
  if ((uint64_t)llabs(phase_us) > one_tick_us) {
    // snap deadline and songTicks edge
    uint32_t save = save_and_disable_interrupts();
    m_deadline_q32  = ((uint64_t)t_next_ref << 32);
    // Align our songTicks so that the next IRQ will land exactly on the next remote tick
    m_songTicks = (uint64_t)floor(refTicksNow_d + 0.5);
    restore_interrupts(save);
    _programNextAlarm();
  } else {
    // gentle: keep target interval, let per-tick slew converge
    // small immediate phase trim helps
    uint32_t save = save_and_disable_interrupts();
    m_deadline_q32 += ((int64_t)phase_us << 32) / 8; // 12.5% phase nudge
    restore_interrupts(save);
    _programNextAlarm();
  }
}

// ----- handlers
void LocalMetronome::onTick(std::function<void(uint64_t)> cb) { m_cbTick = std::move(cb); }
void LocalMetronome::onBeat(std::function<void(uint64_t, uint32_t, uint16_t)> cb){ m_cbBeat = std::move(cb); }
void LocalMetronome::onBar (std::function<void(uint64_t, uint32_t)> cb){ m_cbBar = std::move(cb); }

// ----- update: drain deferred events
void LocalMetronome::update() {
  if (m_dispatchInIrq) return; // nothing to drain
  while (m_queue.tail != m_queue.head) {
    Event e = m_queue.buf[m_queue.tail & m_queue.mask];
    m_queue.tail++;
    if (e.type == EVT_TICK) {
      if (m_cbTick) m_cbTick(e.ticks);
    } else if (e.type == EVT_BEAT) {
      if (m_cbBeat) m_cbBeat(e.ticks, e.bar, e.beat);
    } else if (e.type == EVT_BAR) {
      if (m_cbBar)  m_cbBar(e.ticks, e.bar);
    }
  }
}

// ----- IRQ glue
void LocalMetronome::_alarmCallback(uint alarm_id, void* user_data) {
  (void)alarm_id;
  reinterpret_cast<LocalMetronome*>(user_data)->_irqStep();
}

void LocalMetronome::_irqStep() {
  if (!m_running) return;

  // Advance musical time
  m_songTicks++;

  // Compute boundaries (only cheap integer ops)
  // Note: events are fired on the FIRST tick inside the new boundary
  bool beatBoundary = (m_ticksPerBeat && ((m_songTicks % m_ticksPerBeat) == 0));
  bool barBoundary  = (m_ticksPerBar  && ((m_songTicks % m_ticksPerBar)  == 0));

  // 1-based bar/beat for user callbacks
  uint64_t bar0  = (m_ticksPerBar ? (m_songTicks / m_ticksPerBar) : 0);
  uint64_t rel   = (m_ticksPerBar ? (m_songTicks % m_ticksPerBar) : 0);
  uint16_t beat1 = (uint16_t)((m_ticksPerBeat ? (rel / m_ticksPerBeat) : 0) + 1);
  uint32_t bar1  = (uint32_t)(bar0 + 1);

  // Dispatch (IRQ or queue)
  if (m_dispatchInIrq) {
    if (m_cbTick) m_cbTick(m_songTicks);
    if (beatBoundary && m_cbBeat) m_cbBeat(m_songTicks, bar1, beat1);
    if (barBoundary  && m_cbBar)  m_cbBar (m_songTicks, bar1);
  } else {
    _post(EVT_TICK, m_songTicks, bar1, beat1);
    if (beatBoundary) _post(EVT_BEAT, m_songTicks, bar1, beat1);
    if (barBoundary)  _post(EVT_BAR,  m_songTicks, bar1, 0);
  }

  // ppm-limited slew towards target interval
  int64_t delta = (int64_t)m_interval_q32_tgt - (int64_t)m_interval_q32_cur;
  if (delta) {
    // limit step size by ppm of current interval
    // step_q32 = current * ppm / 1e6, at least 1 LSB if delta is non-zero
    uint64_t cur = m_interval_q32_cur;
    uint64_t step = (cur * m_maxPPMperTick) / 1000000ULL;
    if (step == 0) step = 1;
    if (delta > 0) {
      if ((uint64_t)delta < step) step = (uint64_t)delta;
      m_interval_q32_cur += step;
    } else {
      uint64_t nd = (uint64_t)(-delta);
      if (nd < step) step = nd;
      m_interval_q32_cur -= step;
    }
  }

  // Schedule next absolute deadline using Q32.32 accumulator
  m_deadline_q32 += m_interval_q32_cur;
  _programNextAlarm();
}

void LocalMetronome::_programNextAlarm() {
  if (m_alarm_id < 0) return;
  uint64_t target_us = m_deadline_q32 >> 32;
  hardware_alarm_set_target(m_alarm_id, target_us);
}

void LocalMetronome::_recomputeDerived() {
  // ticksPerBeat = ppqn * (4 / beatUnit)
  // Avoid floats: multiply first, divide last
  m_ticksPerBeat = (uint32_t)((uint32_t)m_ppqn * 4u) / (uint32_t)(m_beatUnit ? m_beatUnit : 4);
  if (m_ticksPerBeat == 0) m_ticksPerBeat = 1;
  m_ticksPerBar  = (uint64_t)m_ticksPerBeat * (uint64_t)(m_beatsPerBar ? m_beatsPerBar : 4);
}

double LocalMetronome::_intervalUsDoubleFrom(float bpm) const {
  // interval_us = 60e6 / (BPM * PPQN * (4/beatUnit))
  double ticks_per_min = (double)bpm * (double)m_ppqn * (4.0 / (double)m_beatUnit);
  if (ticks_per_min <= 0.0) ticks_per_min = 1.0;
  return 60000000.0 / ticks_per_min;
}

void LocalMetronome::_setIntervalTargetFrom(float bpm) {
  double interval_us = _intervalUsDoubleFrom(bpm);
  // Q32.32
  uint64_t q32 = (uint64_t)(interval_us * (double)(1ULL<<32) + 0.5);
  if (q32 == 0) q32 = 1;
  uint32_t save = save_and_disable_interrupts();
  m_interval_q32_tgt = q32;
  restore_interrupts(save);
}

void LocalMetronome::_post(EventType t, uint64_t atTicks, uint32_t bar, uint16_t beat) {
  uint32_t head = m_queue.head;
  uint32_t next = head + 1;
  if (((next - m_queue.tail) & m_queue.mask) == 0) { // full if next==tail (mod pow2)
    m_queueDrops++;
    return;
  }
  Event& e = m_queue.buf[head & m_queue.mask];
  e.type  = (uint8_t)t;
  e.beat  = beat;
  e.bar   = bar;
  e.ticks = atTicks;
  // publish
  m_queue.head = next;
}
```

---

### Example sketch (`examples/BasicBBT/BasicBBT.ino`)

```cpp
#include <LocalMetronome.h>
LocalMetronome metro;

const int LED = 25;

void setup() {
  pinMode(LED, OUTPUT);

  MetronomeConfig cfg;
  cfg.bpm = 120.0f;
  cfg.ppqn = 96;
  cfg.beatsPerBar = 4;
  cfg.beatUnit = 4;
  cfg.startRunning = true;
  cfg.dispatchInIrq = false; // default: defer to loop()
  metro.begin(cfg);

  metro.onBar([](uint64_t t, uint32_t bar){
    // flash LED on bar
    digitalWrite(25, HIGH);
  });
  metro.onBeat([](uint64_t t, uint32_t bar, uint16_t beat){
    // turn LED off on beat
    digitalWrite(25, LOW);
  });
  metro.onTick([](uint64_t t){
    // light work only; ticks happen a lot
  });
}

void loop() {
  metro.update(); // deliver deferred callbacks

  // Example: dumb tempo ramp every few seconds (slewed)
  static uint32_t lastMs = 0;
  uint32_t now = millis();
  if (now - lastMs > 4000) {
    lastMs = now;
    float bpm = metro.getBPM();
    bpm = (bpm < 140.0f) ? (bpm + 10.0f) : 100.0f;
    metro.setBPM(bpm, true); // slew to new tempo
  }

  // Example: external sync packet (pseudo)
  // if (Serial.available() >= sizeof(SyncPacket)) {
  //   SyncPacket pkt; Serial.readBytes((char*)&pkt, sizeof(pkt));
  //   metro.externalSyncUpdate(pkt.songTicks, pkt.sender_us, pkt.bpm, pkt.beatsPerBar, pkt.beatUnit);
  // }
}
```

---

## Notes & gotchas (read me once)

- **Absolute-deadline scheduling:** the IRQ doesn‚Äôt use ‚Äúnow + interval‚Äù ‚Äî it adds the Q32.32 interval to a Q32.32 absolute accumulator and programs the alarm to `deadline_us`. That kills drift and keeps jitter tight.
    
- **When do beat/bar events fire?** On the _first tick_ inside a new boundary (i.e., when `tickWithinBeat == 0`). Bars/beats are **1-based** in callbacks, ticks are absolute.
    
- **Deferred dispatch by default:** IRQ only posts tiny event structs into an SPSC ring. Call `update()` in your loop to run handlers. If you _must_ run in IRQ, set `dispatchInIrq=true` and keep handlers microscopic.
    
- **Slew behavior:** `setBPM(bpm,true)` and `externalSyncUpdate()` converge using a per-tick ppm-limited step (default 2000 ppm). Hard changes use `setBPM(bpm,false)` or snap path in `externalSyncUpdate()`.
    
- **External sync:** If you can‚Äôt trust `sender_time_us` (different clock domains), pass `0`. The code then treats `refTicks` as ‚Äúnow‚Äù and still locks phase gently. If you _do_ exchange timestamps (UART round-trip or LoRa ping), pass them for cleaner phase calc.
    
- **Threading/cores:** Call `begin()` on the core you want to own the metronome. Run `update()` on that same core. If audio lives on the other core, communicate via your own lock-free mailboxes.
    
- **Queue sizing:** `maxEventQueue` is rounded up to a power of two. If you ever see missed UI updates, bump it.
    

---

If you want, Bob can add a tiny UART `SyncPacket` helper (crc, versioning) and a micro test that scopes a GPIO on tick to compute jitter. But this gets you a solid, testable baseline you can start dropping into modules today.

> This is cool and all, but the code is very rude.