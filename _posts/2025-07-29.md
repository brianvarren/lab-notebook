
Now we need to get working on something else. We need to design a robust .wav file loader that can access the SD card of the Olimex pico2-xxl and load files from it. We're going to design a sample looper that's capable of keeping very high sample rate samples available for playback, increasing the quality we're able to output. And eventually, when we create an audio codec board, we'll have the output fidelity to appreciate having higher quality samples on hand.

There are a few ways we could go about this:

## 1. **Full In-RAM Loading**

### **Approach:**

- Read the entire `.wav` file into RAM, parse the header, and keep the sample buffer in memory.

### **Pros:**

- Simplest code (no streaming logic)
- Super-fast, random access to any sample (great for slicing, pitch-shifting, granular tricks)
- No SD card latency during playback (just on initial load)

### **Cons:**

- Severely limited by RAM: the RP2040’s internal RAM is 264kB; Olimex Pico2-XXL’s **external PSRAM** (8MB) helps, but is still a limit. 8MB = ~45 seconds stereo/16bit/44.1kHz, or 90 seconds mono.
- Large files can't be loaded at all—must enforce file size limits or build a paging scheme.
- Consumes RAM that could otherwise go to voices, FX, UI, etc.

**Best for:** Short samples, one-shots, drumkits, granular, and fast/complex scrubbing.

---

## 2. **Direct-from-SD Streaming (Block-by-Block)**

### **Approach:**

- Keep the .wav file on SD card and read only the chunks needed (e.g. a buffer of N samples ahead).
- Double-buffering: while one chunk is being played, the next is loaded in the background.

### **Pros:**

- Can play arbitrarily long samples (minutes, hours), limited only by SD card size.
- Minimal RAM usage (just a read buffer, e.g. a few KB)
- Makes long loops, backing tracks, or “tape” workflows possible.

### **Cons:**

- SD card access is **slow** (especially on cheap cards). Need to optimize for block-aligned reads.
- If your buffer is too small or SD access is interrupted, playback glitches (pops, dropouts).
- Random-access is slower (scrubbing, pitch-jumping requires more SD reads)
- Complex logic: must manage buffering, prefetching, underrun handling.

**Best for:** Long samples, backing tracks, minimal RAM systems, and simple playback (vs. heavy manipulation).

---

## 3. **Hybrid: Pre-parse and Index, Stream Data**

### **Approach:**

- On startup (or file selection), parse the `.wav` header and build an **index** (start position, length, block map).
- Only read audio data into a circular buffer as needed during playback.

### **Pros:**

- Mixes the benefits: fast header parsing and info access, limited RAM, works for long files.
- Can support advanced features: loop points, multi-sample instruments, even cue points.
- Less SD card access during “normal” playback; seek performance improved.

### **Cons:**

- More complex to implement: index management, buffer underflow/overflow checks, resync after seeks.
- Still bottlenecked by SD card read speed and potential latency spikes.

**Best for:** Samplers where flexibility and responsiveness matter, and you want to allow larger sample sets than RAM alone can hold.

---

## 4. **Compressed or Preprocessed Sample Formats**

### **Approach:**

- Store samples on SD card in a format that’s faster to parse/load, e.g. raw PCM, or even compressed (IMA ADPCM, u-law, custom).

### **Pros:**

- Faster loading, less parsing at runtime.
- Compression means more samples fit on SD, and less read bandwidth required.

### **Cons:**

- Must preprocess files on the PC (no “drop any .wav and play” UX)
- Compression adds CPU cost (unless hardware supports it), and degrades quality
- Not truly “.wav compatible” in the sense of user expectations.

**Best for:** Massive libraries, low-bandwidth systems, or if you want to support lo-fi/characterful playback.

---

## 5. **Fixed Sample Banks (ROM-style, flash-based)**

### **Approach:**

- Store samples in QSPI flash, PSRAM, or baked into firmware—no runtime file parsing, just pointers to static arrays.

### **Pros:**

- Fastest possible load and play, no file system overhead, great for performance/latency.
- Predictable resource usage.

### **Cons:**

- Not flexible (user can’t drop in new samples easily)
- Not as “open” or “hacker-friendly”
- Usually used for factory presets, not for DIY tools.

**Best for:** Commercial modules, low-latency drum machines, factory content.

---

## **Other Considerations**

- **File System:**  
    RP2040 + FatFs can handle FAT16/32 SD cards. Beware long filenames, deep directories, and very large files—keep it simple for reliability.
    
- **.wav Parsing:**  
    Only support **PCM** (uncompressed) for now. Many .wav files use “junk” chunks or nonstandard headers, so robust parsing (skip unknown chunks!) is important.
    
- **Audio Output Path:**  
    PWM output will limit you to ~10–12 bits of effective resolution and lots of noise at high frequencies; codec output will make all this work shine. You’ll want a clean separation between “sample read” and “output driver” in your architecture.
    
- **User Experience:**  
    If your device needs to quickly scan many files, consider scanning only headers for preview (names, lengths, sample rates) and loading data on-demand.
    


I think we'll start with the simplest option first, just to prove out that it works, and maybe the 8MB limitation is enough. Before starting any of this I want to prepare for edge cases: I want to first always know how much PSRAM is available. I want to strip stereo files to mono. I want to normalize files on load to the current bit depth's dynamic range. I want to limit (or truncate) any file that's larger than our available PSRAM. I want to display reasonably detailed but concise error messages if any file is selected that's invalid. I want to try to work with as many file formats as possible (.wav sample rates, bit depths, data types). I want to reject mp3, ogg, or any other format besides .wav. And maybe we write a small, fast python script that runs on gradio as a quick "file check" to let us know if the samples we're about to upload will be compatible with our architecture.

So here's the plan:

**1. Check PSRAM Capacity**

- On boot or file load, query available PSRAM (e.g., via Olimex API or manually track allocations).
- Store the available size globally for quick checks before attempting loads.

**2. Stereo to Mono**

- For all files, detect `numChannels`. If stereo (2), average L+R for each sample during import.
- Saves RAM, simplifies playback logic, and prevents “file too big” surprises.

**3. Normalize to Bit Depth**

- After reading samples (int16, int24, float, etc.), scan for peak and scale all samples so the highest |value| matches the dynamic range of the output (e.g., 0–4095 for 12-bit PWM).
- Always use floating point internally during conversion, then quantize.

**4. Convert to Output Range**

- Before saving to RAM, map normalized audio to your desired range
	- PWM: 0–4095 (12 bits, unsigned)
	- Codec: -32768–32767 (if using signed 16-bit I2S/DAC)
- This allows the same loader to serve either output driver.

**5. Modular Output Path**

- Implement your playback/output routine as a “sink” function (e.g., `output_sample(uint16_t sample)`), which is set at runtime for PWM or I2S/DAC.
- Keep your sample buffer format generic, and abstract output hardware behind a simple interface.

**6. File Size Truncation**

- Before loading audio data, calculate bytes required (`numSamples * sizeof(uint16_t)` after conversion).
- If not enough PSRAM, load only up to what fits, display “File too large—truncated” on screen.

**7. Concise, Useful Errors**

- Print: file open error, invalid .wav (bad header), unsupported bit depth/rate, file too big, truncated, non-.wav file, etc.
- Use a numeric error code for each, and a short description for UI or serial output.

**8. Maximize Format Support**

- Support: 8, 16, 24, 32-bit PCM; float32; any sample rate; mono/stereo (always downmixed).
- Skip or warn on unsupported “chunks” (JUNK, FMT with non-PCM, etc.).
- Always reject: MP3, OGG, anything not .wav extension or not “RIFF/WAVE”.